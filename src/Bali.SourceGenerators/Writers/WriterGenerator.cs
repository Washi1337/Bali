using System.Collections.Generic;
using System.Linq;
using CodeGenHelpers;
using Microsoft.CodeAnalysis;

namespace Bali.SourceGenerators.Writers
{
    [Generator]
    public class WriterGenerator : SourceGeneratorBase
    {
        private static readonly string AttributeSource;
        private static readonly string FullAttributeName = $"{AttributeNamespace}.{AttributeName}";

        private const string AttributeNamespace = "Bali.SourceGeneration";
        private const string AttributeName = "AutoWriterAttribute";
        private const string CustomName = "CustomWriterConverterAttribute";
        private const string WriterNamespace = "Bali.Attributes.Writers";

        public WriterGenerator()
            : base(FullAttributeName, AttributeSource)
        {
        }

        static WriterGenerator()
        {
            var builder = CodeBuilder.Create(AttributeNamespace)
                .AddNamespaceImport("System")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddClass(AttributeName)
                    .SetBaseClass("Attribute")
                    .AddAttribute("CompilerGenerated")
                    .AddAttribute("AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)")
                .Builder
                .AddClass(CustomName)
                    .SetBaseClass("Attribute")
                    .AddAttribute("CompilerGenerated")
                    .AddAttribute("AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)")
                    .AddProperty("Source", Accessibility.Internal)
                        .SetType("string")
                    .Class
                    .AddConstructor(Accessibility.Internal)
                        .AddParameter("string", "source")
                        .WithBody(w => w.AppendLine("Source = source;"))
                .Class;

            AttributeSource = builder.Build();
        }

        protected override void Execute(List<INamedTypeSymbol> targets, GeneratorExecutionContext context)
        {
            foreach (var attribute in targets)
            {
                string source = ProcessClass(attribute);
                context.AddSource(attribute.Name + "Writer", source);
            }

            var builder = CodeBuilder.Create("Bali.SourceGeneration")
                .AddNamespaceImport("System.Collections.Generic")
                .AddNamespaceImport("Bali.Attributes.Writers")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddClass("AutoGeneratedWriters")
                    .AddAttribute("CompilerGenerated")
                    .MakeStaticClass()
                    .MakeInternalClass()
                    .AddMethod("AddToCache", Accessibility.Internal)
                        .MakeStaticMethod()
                        .WithReturnType("void")
                        .AddParameter("IJvmAttributeDirector", "director")
                        .WithBody(w =>
                        {
                            foreach (var target in targets)
                            {
                                string attributeName = target.Name;
                                string withoutAttribute = attributeName.Substring(0, attributeName.Length - 9);
                                w.AppendLine($"director[\"{withoutAttribute}\"] = new {attributeName}Writer(director);");
                            }
                        })
                .Class;
            
            context.AddSource("AutoGeneratedWriters", builder.Build());
        }

        private static string ProcessClass(INamedTypeSymbol attribute)
        {
            string attributeName = attribute.Name;
            string builderName = attributeName + "Writer";
            
            var builder = CreateBuilder(builderName, attributeName);
            var steps = new List<string>();

            foreach (var property in attribute.GetMembers().OfType<IPropertySymbol>())
            {
                if (property.Type is not INamedTypeSymbol type)
                {
                    steps.Add($"throw new NotSupportedException(\"Unsupported type {property.Type.Name}\");");
                    continue;
                }

                var attributes = property.GetAttributes();
                if (attributes.FirstOrDefault(a => a.AttributeClass?.Name == CustomName) is { } custom)
                {
                    steps.Add(custom.ConstructorArguments[0].Value as string);
                }
                else
                {
                    var processor = new TypeProcessor(builder.Class, type, $"attribute.{property.Name}");
                    steps.Add(processor.Process());
                }
            }

            builder.WithBody(w =>
            {
                foreach (string step in steps)
                    w.AppendLine(step);
            });
            
            return builder.Class.Build();
        }

        private static MethodBuilder CreateBuilder(string builderName, string attributeName)
        {
            return CodeBuilder.Create(WriterNamespace)
                .AddNamespaceImport("System")
                .AddNamespaceImport("System.IO")
                .AddNamespaceImport("System.Collections.Generic")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddNamespaceImport("Bali.IO")
                .AddNamespaceImport("Bali.Attributes")
                    .AddClass(builderName)
                    .WithSummary($"Provides an implementation of the <see cref=\"IJvmAttributeWriter\"/> contract that can write <see cref=\"{attributeName}\"/>s.")
                    .AddAttribute("CompilerGenerated")
                    .MakePublicClass()
                    .SetBaseClass($"JvmAttributeWriterBase<{attributeName}>")
                    .AddConstructor(Accessibility.Public)
                        .WithInheritDoc()
                        .WithBaseCall(new Dictionary<string, string>
                        {
                            { "IJvmAttributeDirector", "director" }
                        })
                        .Class
                    .AddProperty("Name", Accessibility.Public)
                        .Override()
                        .SetType("string")
                        .WithGetterExpression($"\"{attributeName.Substring(0, attributeName.Length - 9)}\"")
                        .WithInheritDoc()
                        .Class
                    .AddMethod("WriteBody", Accessibility.Protected)
                        .Override()
                        .WithInheritDoc()
                        .AddParameter("Stream", "stream")
                        .AddParameter(attributeName, "attribute");
        }
    }
}