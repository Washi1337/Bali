using System.Collections.Generic;
using System.Linq;
using CodeGenHelpers;
using Microsoft.CodeAnalysis;

namespace Bali.SourceGenerators.Readers
{
    [Generator]
    public class ReaderGenerator : SourceGeneratorBase
    {
        private static readonly string AttributeSource;
        private static readonly string FullAttributeName = $"{AttributeNamespace}.{AttributeName}";

        private const string AttributeNamespace = "Bali.SourceGeneration";
        private const string AttributeName = "AutoReaderAttribute";
        private const string CustomName = "CustomReaderConverterAttribute";
        private const string ReaderNamespace = "Bali.Attributes.Readers";

        public ReaderGenerator()
            : base(FullAttributeName, AttributeSource)
        {
        }

        static ReaderGenerator()
        {
            var builder = CodeBuilder.Create(AttributeNamespace)
                .AddNamespaceImport("System")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddClass(AttributeName)
                    .SetBaseClass("Attribute")
                    .AddAttribute("CompilerGenerated")
                    .AddAttribute("AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)")
                .Builder
                .AddClass(CustomName)
                    .SetBaseClass("Attribute")
                    .AddAttribute("CompilerGenerated")
                    .AddAttribute("AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)")
                    .AddProperty("Source", Accessibility.Internal)
                        .SetType("string")
                    .Class
                    .AddConstructor(Accessibility.Internal)
                        .AddParameter("string", "source")
                        .WithBody(w => w.AppendLine("Source = source;"))
                .Class;

            AttributeSource = builder.Build();
        }

        protected override void Execute(List<INamedTypeSymbol> targets, GeneratorExecutionContext context)
        {
            foreach (var attribute in targets)
            {
                string source = ProcessClass(attribute);
                context.AddSource(attribute.Name + "Reader", source);
            }

            var builder = CodeBuilder.Create("Bali.SourceGeneration")
                .AddNamespaceImport("System.Collections.Generic")
                .AddNamespaceImport("Bali.Attributes.Readers")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddClass("AutoGeneratedReaders")
                    .AddAttribute("CompilerGenerated")
                    .MakeStaticClass()
                    .MakeInternalClass()
                    .AddMethod("AddToCache", Accessibility.Internal)
                        .MakeStaticMethod()
                        .WithReturnType("void")
                        .AddParameter("IJvmAttributeReaderFacade", "facade")
                        .WithBody(w =>
                        {
                            foreach (var target in targets)
                            {
                                string attributeName = target.Name;
                                string withoutAttribute = attributeName.Substring(0, attributeName.Length - 9);
                                w.AppendLine($"facade[\"{withoutAttribute}\"] = new {attributeName}Reader(facade);");
                            }
                        })
                .Class;
            
            context.AddSource("AutoGeneratedReaders", builder.Build());
        }

        private static string ProcessClass(INamedTypeSymbol attribute)
        {
            string attributeName = attribute.Name;
            string builderName = attributeName + "Reader";
            
            var builder = CreateReader(builderName, attributeName);
            var steps = new List<string>();

            var properties = attribute.GetMembers().OfType<IPropertySymbol>().ToArray();
            foreach (var property in properties)
            {
                if (property.Type is not INamedTypeSymbol type)
                {
                    steps.Add($"throw new NotSupportedException(\"Unsupported type {property.Type.Name}\");");
                    continue;
                }

                var attributes = property.GetAttributes();
                if (attributes.FirstOrDefault(a => a.AttributeClass?.Name == CustomName) is { } custom)
                {
                    steps.Add(custom.ConstructorArguments[0].Value as string);
                }
                else
                {
                    var processor = new TypeProcessor(builder.Class, type, $"var {property.Name} = ");
                    steps.Add(processor.Process());
                }
            }

            builder.WithBody(w =>
            {
                w.AppendLine("_ = reader.ReadU4();");
                foreach (string step in steps)
                    w.AppendLine(step);

                string parameters = string.Join(", ", properties.Select(p => p.Name).Prepend("nameIndex"));
                w.AppendLine($"return new {attributeName}({parameters});");
            });
            
            return builder.Class.Build();
        }

        private static MethodBuilder CreateReader(string builderName, string attributeName)
        {
            return CodeBuilder.Create(ReaderNamespace)
                .AddNamespaceImport("System")
                .AddNamespaceImport("System.IO")
                .AddNamespaceImport("System.Collections.Generic")
                .AddNamespaceImport("System.Runtime.CompilerServices")
                .AddNamespaceImport("Bali.IO")
                .AddNamespaceImport("Bali.Attributes")
                    .AddClass(builderName)
                    .WithSummary($"Provides an implementation of the <see cref=\"JvmAttributeReaderBase\"/> contract that can read <see cref=\"{attributeName}\"/>s.")
                    .AddAttribute("CompilerGenerated")
                    .MakePublicClass()
                    .SetBaseClass("JvmAttributeReaderBase")
                    .AddConstructor(Accessibility.Public)
                        .WithInheritDoc()
                        .WithBaseCall(new Dictionary<string, string>
                        {
                            { "IJvmAttributeReaderFacade", "attributeReaderFacade" }
                        })
                        .Class
                    .AddProperty("Name", Accessibility.Public)
                        .Override()
                        .SetType("string")
                        .WithGetterExpression($"\"{attributeName.Substring(0, attributeName.Length - 9)}\"")
                        .WithInheritDoc()
                        .Class
                    .AddMethod("Read", Accessibility.Public)
                        .Override()
                        .WithReturnType("JvmAttribute")
                        .WithInheritDoc()
                        .AddParameter("IBigEndianReader", "reader")
                        .AddParameter("ushort", "nameIndex");
        }
    }
}